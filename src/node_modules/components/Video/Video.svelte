<script>
  import { onDestroy, tick, createEventDispatcher } from "svelte";
  import { _ } from "svelte-i18n";
  import Ui from "./Ui.svelte";

  const dispatch = createEventDispatcher();

  let duration;
  let showControlsTimeout;
  let className = "";
  let hydrated = false;
  let hydrating = false;
  let currentPoster;
  let buffered;
  let _src;
  let allowScrubbing = false;
  let target;
  let hideControlsOnPause = true;
  let customControls;

  export let videoElement = null;
  export let src;
  export let video;
  export let autoplay;
  export let muted;
  export let poster;
  export let type;
  export let controls;
  export let paused = true;
  export let preload = "none";
  export let playhead = 0;
  export { className as class };

  $: customControls = !controls;
  $: ((p) => {
    if (currentPoster !== p) {
      currentPoster = p;
      reset();
    }
  })(poster);
  $: showControls = paused;
  $: paused && !hideControlsOnPause && clearTimeout(showControlsTimeout);

  onDestroy((_) => videoElement && videoElement.pause());

  function handleMouseenter(e) {
    e = e.detail;
    showControls = true;
  }

  function handleMouseleave(e) {
    e = e.detail;
    showMediaControls();
  }

  function showMediaControls() {
    if (!duration) return; // nothing loaded
    clearTimeout(showControlsTimeout);
    showControlsTimeout = setTimeout(() => (showControls = false), 4000);
    showControls = true;
  }

  function handleMousemove(e) {
    e = e.detail;
    showMediaControls();
    allowScrubbing && handleScrubbing(e);
  }

  function handleClearTimeout(e) {
    clearTimeout(showControlsTimeout);
  }

  function handleScrubbing(e) {
    if (!(e.buttons & 1)) return; // mouse not down
    if (!duration) return; // videoElement not loaded yet

    const { left, right } =
      videoElement && videoElement.getBoundingClientRect();
    if (left === undefined || right === undefined) return;

    playhead = (duration * (e.clientX - left)) / (right - left);
    scrubbing = true;
  }

  function handlePlayPause(e) {
    !videoElement.getAttribute("src") &&
      videoElement.setAttribute("src", videoElement.dataset.src);
    // we have switched off preload, so must load first
    !duration && !videoElement.promise && videoElement.load();

    if (!videoElement.promise || paused) {
      playhead && (videoElement.currentTime = playhead);
      videoElement.promise = videoElement.play();
    } else {
      videoElement.promise
        .then((_) => {
          // playback started so we can safely pause
          videoElement.pause();
        })
        .catch((_) => {
          console.log("Auto-play was prevented");
        });
    }
  }

  function handlePause(e) {
    dispatch("player:paused");
  }

  function handleRewind(e) {
    let step = e.detail || 15;
    let s;
    playhead -= (s = playhead - step) < 0 ? step + s : step;
    dispatch("player:rwd");
  }

  function handleForeward(e) {
    let step = e.detail || 15;
    playhead += playhead + step > duration ? duration - playhead : step;
    dispatch("player:fwd");
  }

  function handleMousedown(e) {
    e = e.detail;
    target = e.currentTarget;

    // we can't rely on the built-in click event, because it fires
    // after a drag â€” we have to listen for clicks ourselves

    function handleMouseup() {
      _src && (src = _src);
      handlePlayPause();
      cancel();
    }

    function handleMouseupAfterDrag() {
      scrubbing = false;
      cancelAfterDrag();
    }

    function cancel() {
      target.removeEventListener("mouseup", handleMouseup);
      target.addEventListener("mouseup", handleMouseupAfterDrag);
      target.addEventListener("mouseleave", handleMouseupAfterDrag);
    }

    function cancelAfterDrag() {
      target.removeEventListener("mouseup", handleMouseupAfterDrag);
      target.removeEventListener("mouseleave", handleMouseupAfterDrag);
    }

    target.addEventListener("mouseup", handleMouseup);

    setTimeout(cancel, 100); // prevent start/stop after scrubbing
  }

  function handleCanPlay(e) {
    dispatch("player:canplay");
  }

  function handleLoadstart(e) {
    hydrating = true;
    hydrated = false;
  }

  function handleLoadedData(e) {
    hydrating = false;
    hydrated = true;
  }

  function handleEmptied(e) {
    hydrated = false;
  }

  function handleAborted(e) {
    duration = undefined;
  }

  function handlePictureInPicture(e) {
    if (document.pictureInPictureElement)
      document.exitPictureInPicture().catch((e) => {});
    else
      videoElement && videoElement.requestPictureInPicture().catch((e) => {});
  }

  function handleFullscreen(e) {
    if (document.fullscreenElement) document.exitFullscreen().catch((e) => {});
    else if (videoElement && videoElement.requestFullscreen)
      videoElement.requestFullscreen();
    else if (videoElement && videoElement.webkitRequestFullScreen)
      videoElement.webkitRequestFullScreen();
  }

  async function reset() {
    if (!duration) return;
    videoElement.pause();
    await tick();
    setTimeout(() => videoElement.load(), 100);
  }
</script>

<div class="player {className}" class:hydrated>
  <div
    class="text-wrapper bg-gradient-to-b from-black"
    class:is-playing={!paused}
  >
    <h2
      class="mdc-typography--headline6 opacity-25"
      class:opacity-25={!video.title}
      style="margin: 0;"
    >
      {video.title || $_("text.empty_title")}
    </h2>
    <h3
      class="mdc-typography--subtitle2 opacity-25"
      class:opacity-25={!video.description}
      style="margin: 0;"
    >
      {video.description || $_("text.empty_description")}
    </h3>
  </div>
  <video
    bind:this={videoElement}
    bind:currentTime={playhead}
    bind:duration
    bind:paused
    bind:buffered
    {poster}
    {preload}
    {controls}
    {muted}
    {type}
    {autoplay}
    on:loadstart={handleLoadstart}
    on:canplay={handleCanPlay}
    on:loadeddata={handleLoadedData}
    on:emptied={handleEmptied}
    on:abort={handleAborted}
    on:pause={handlePause}
    x-webkit-airplay="allow"
    data-src={src}
  >
    <source type="video/{type}" />
    <track kind="captions" />
    Your browser does not support the
    <code>video</code>
    element.
  </video>
  {#if customControls}
    <Ui
      on:mousemove={handleMousemove}
      on:mouseenter={handleMouseenter}
      on:mouseleave={handleMouseleave}
      on:clearTimeout={handleClearTimeout}
      on:fullscreen={handleFullscreen}
      on:play-pause={handlePlayPause}
      on:rwd={handleRewind}
      on:fwd={handleForeward}
      on:pip={handlePictureInPicture}
      bind:time={playhead}
      {duration}
      {showControls}
      {paused}
      {buffered}
    />
  {/if}
</div>

<style>
  .player {
    position: relative;
    user-select: none;
  }
  video {
    width: 100%;
    width: var(--player-w);
    object-position: center;
    object-fit: cover;
  }
  .hydrated video {
    object-fit: contain;
  }
  .is-playing {
    opacity: 0;
    right: 2000px;
    transform: translate(100%);
    transform-origin: 100% center;
    transition-property: opacity, transform;
    transition-duration: 0.1s;
    transition-timing-function: ease-in-out;
  }
  .text-wrapper {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 40%;
    right: inherit;
    z-index: 1;
    transform: translateX(0);
    transform-origin: 0 center;
    transition-property: transform;
    transition-duration: 0.3s;
    transition-timing-function: ease-in-out;
  }
  .text-wrapper,
  .text-wrapper > * {
    pointer-events: none;
  }
  .text-wrapper > * {
    color: var(--text-light);
    padding: 5px 17px;
  }
</style>
