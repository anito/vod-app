export function get(endpoint) {
  return fetch(endpoint, {
    method: 'GET',
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json',
    },
  }).then((r) => r.json());
}
export function post(endpoint, data = {}) {
  return fetch(endpoint, {
    method: 'POST',
    credentials: 'include',
    body: JSON.stringify(data),
    headers: {
      'Content-Type': 'application/json',
    },
  }).then((r) => r.json());
}
export function del(endpoint, id) {
  return fetch(endpoint, {
    method: 'DELETE',
    credentials: 'include',
    body: id,
    headers: {
      'Content-Type': 'application/json',
    },
  }).then((r) => r.json());
}
export function put(endpoint, data = {}) {
  return fetch(endpoint, {
    method: 'PUT',
    credentials: 'include',
    body: JSON.stringify(data),
    headers: {
      'Content-Type': 'application/json',
    },
  }).then((r) => r.json());
}
export async function extendSession() {
  let res;
  try {
    res = await get('session');
  } catch {
    (_) => {};
  }

  if (res) {
    proxyEvent('session:extended', { expires: res.expires });
  }
}
export function equals(obj_1, obj_2) {
  let json_1 = typeof obj_1 === 'object' && JSON.stringify(obj_1);
  let json_2 = typeof obj_2 === 'object' && JSON.stringify(obj_2);
  if (!!json_1 && !!json_2) {
    return json_1 === json_2;
  }
  return false;
}
export function minDigits(m) {
  toLocaleString('en-US', {
    //this is the function that formats the numbers
    minimumIntegerDigits: 2, //change this to your minimum length
    useGrouping: false,
  });
}
export function formatter(d) {
  let h, hrs, m, min, s, sec;
  hrs = d / 1000 / 60 / 60;
  min = !isNaN(((hrs % Math.floor(hrs)) * 60) % 60) || 0;
  sec = !isNaN(((min % Math.floor(min)) * 60) % 60) || 0;
  return `${Math.floor(hrs)}:${Math.floor(min)}:${Math.floor(sec)}`;
}
export function createRedirectSlug(page) {
  let queries = Object.entries(page.query)
    .map(([key, val]) => `${key}=${val}`)
    .join('&');
  let bit = '';
  return (bit = `?redirect=${page.path}`) && queries ? `${bit}&${queries}` : bit;
}
export function redirectPath(page, session) {
  let path, tab;

  path = session.role === 'Administrator' ? 'users' : 'videos';
  if (session.role !== 'Administrator') return path;
  return page.query.redirect && (path = page.query.redirect)
    ? (tab = page.query.tab)
      ? path + `?tab=${tab}`
      : path
    : path;
}
export function windowSize() {
  var width = 0,
    height = 0;
  if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
    width = document.documentElement.clientWidth;
    height = document.documentElement.clientHeight;
  } else {
    if ('number' == typeof window.innerWidth) {
      width = window.innerWidth;
      height = window.innerHeight;
    } else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
      width = document.body.clientWidth;
      height = document.body.clientHeight;
    }
  }
  return {
    height: height,
    width: width,
  };
}
// https://gist.github.com/faisalman/4213592
export let convert = (() => {
  const convertBase = (num) => {
    return {
      from: (baseFrom) => {
        return {
          to: (baseTo) => {
            return parseInt(num, baseFrom).toString(baseTo);
          },
        };
      },
    };
  };

  return {
    dec2Hex: (num, rel) => {
      rel && (num *= 255);
      return convertBase(num).from(10).to(16);
    },
  };
})();
export const proxyEvent = function (eventType, detail = {}) {
  let type = typeof eventType === 'string' ? eventType : detail.eventType;
  if (typeof window !== 'undefined') window.dispatchEvent(new CustomEvent(type, { detail }));
};
export const recoverSession = function (session) {
  if (!session || session.expires < Date.now) return;
  if (typeof window !== 'undefined') window.dispatchEvent(new CustomEvent('session:started'));
};
export const __key__ = {};
export const __session__ = {};
