export function get(endpoint) {
  return fetch(endpoint, {
    method: "GET",
    credentials: "include",
    headers: {
      "Content-Type": "application/json",
    },
  }).then((r) => r.json());
}

export function post(endpoint, data = {}) {
  return fetch(endpoint, {
    method: "POST",
    credentials: "include",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json",
    },
  }).then((r) => r.json());
}

export function del(endpoint, id) {
  return fetch(endpoint, {
    method: "DELETE",
    credentials: "include",
    body: id,
    headers: {
      "Content-Type": "application/json",
    },
  }).then((r) => r.json());
}

export function put(endpoint, data = {}) {
  return fetch(endpoint, {
    method: "PUT",
    credentials: "include",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json",
    },
  }).then((r) => r.json());
}

export async function extendSession() {
  let res;
  try {
    const { expires } = { ...res } = await get("session");
    if (expires) {
      proxyEvent("session:extended", { expires });
    }
  } catch {
    (_) => {};
  }

}

export function equals(obj_1, obj_2) {
  let json_1 = typeof obj_1 === "object" && JSON.stringify(obj_1);
  let json_2 = typeof obj_2 === "object" && JSON.stringify(obj_2);
  if (!!json_1 && !!json_2) {
    return json_1 === json_2;
  }
  return false;
}

export function minDigits(m) {
  toLocaleString("en-US", {
    //this is the function that formats the numbers
    minimumIntegerDigits: 2, //change this to your minimum length
    useGrouping: false,
  });
}
export function formatter(d) {
  let h, hrs, m, min, s, sec;
  hrs = d / 1000 / 60 / 60;
  min = !isNaN(((hrs % Math.floor(hrs)) * 60) % 60) || 0;
  sec = !isNaN(((min % Math.floor(min)) * 60) % 60) || 0;
  return `${Math.floor(hrs)}:${Math.floor(min)}:${Math.floor(sec)}`;
}

export function createRedirectSlug(page) {
  let exeptions = ['login']
  let bit = "";
  let redirect;
  let filterPath = (path) => {
    for (let i in exeptions) path = path.replace(`/${exeptions[ i ]}`, '/')
    return path;
  }
  let queries = Object.entries(page.query)
    .map(([key, val]) => `${key}=${val}`)
    .join("&");
  return (bit = `?redirect=${filterPath(page.path)}`) && queries
    ? `${bit}&${queries}`
    : bit;
}

// mimics window.location.search with sappers page.query object if we have no window
export function locationSearch(page) {
  let search = Object.entries(page.query)
    .map(([key, val]) => `${key}=${val}`)
    .join("&");
  if (search) return new String().concat("?", search);
  else return "";
}

export function redirectPath(page, session = {}) {
  let path;

  if (page.query.redirect) {
    path = page.query.redirect;
  } else {
    path = session.role === "Administrator" ? "users" : "videos";
    if (path === "users" && session.user) {
      path = path.concat("/", session.user.id);
    }
  }
  return path.concat(parseQuery(page.query, ["token", "redirect"]));
}

export function parseQuery(query, exclude) {
  let concated = "?";
  for (let key in query) {
    exclude.indexOf(key) < 0 &&
      (concated = concated.concat(`${key}=${query[key]}&`));
  }
  return concated.slice(0, -1);
}

export function windowSize() {
  var width = 0,
    height = 0;
  if (
    document.documentElement &&
    (document.documentElement.clientWidth ||
      document.documentElement.clientHeight)
  ) {
    width = document.documentElement.clientWidth;
    height = document.documentElement.clientHeight;
  } else {
    if ("number" == typeof window.innerWidth) {
      width = window.innerWidth;
      height = window.innerHeight;
    } else if (
      document.body &&
      (document.body.clientWidth || document.body.clientHeight)
    ) {
      width = document.body.clientWidth;
      height = document.body.clientHeight;
    }
  }
  return {
    height: height,
    width: width,
  };
}

// https://gist.github.com/faisalman/4213592
export let convert = (() => {
  const convertBase = (num) => {
    return {
      from: (baseFrom) => {
        return {
          to: (baseTo) => {
            return parseInt(num, baseFrom).toString(baseTo);
          },
        };
      },
    };
  };

  return {
    dec2Hex: (num, rel) => {
      rel && (num *= 255);
      return convertBase(num).from(10).to(16);
    },
  };
})();

export const proxyEvent = function (eventType, detail = {}) {
  let type = typeof eventType === "string" ? eventType : detail.eventType;
  if (typeof window !== "undefined")
    window.dispatchEvent(new CustomEvent(type, { detail }));
};

// https://gist.github.com/codeguy/6684588
export function slugify(str) {
  str = str.replace(/^\s+|\s+$/g, ""); // trim
  str = str.toLowerCase();

  // remove accents, swap ñ for n, etc
  var from = "àáäâèéëêìíïîòóöôùúüûñç·/_,:;";
  var to = "aaaaeeeeiiiioooouuuunc------";
  for (var i = 0, l = from.length; i < l; i++) {
    str = str.replace(new RegExp(from.charAt(i), "g"), to.charAt(i));
  }

  str = str
    .replace(/[^a-z0-9 -]/g, "") // remove invalid chars
    .replace(/\s+/g, "-") // collapse whitespace and replace by -
    .replace(/-+/g, "-"); // collapse dashes

  return str;
}

export function placehoderDotComAvatar(name = "?") {
  const placeholder = "https://via.placeholder.com/100x100.png?text=";
  return `${placeholder}${name
    .split(" ")
    .map((val) => val.substring(0, 1))
    .join("")}`;
}

export const __key__ = {};
export const __session__ = {};
